# Вложенные списки. Часть 2.
# СПИРАЛЬ
# Требуется вывести квадрат, состоящий из N×N клеток, заполненных числами от 1 до N2 по спирали (см. примеры).
# Входные данные:
# Программа получает на вход одно число n.
# Выходные данные:
# Программа должна вывести матрицу, заполненную числами от 1 до N2 по спирали, при этом между числами может быть любое
# количество пробелов. Не допускается начинать спираль в ином, кроме верхнего левого, углу, закручивать спираль против
# часовой стрелки или изнутри наружу.
# Sample Input:
# 3
# Sample Output:
# 1 2 3
# 8 9 4
# 7 6 5
n = int(input())
mas = [[0]*n for i in range(n)]
i = 1
x = 0
y = -1
d_row = 0 #  -1 0 1
d_column = 1 # -1 0 1
length = len(str(n**2))
while i <= n**2:
    if 0 <= x + d_row < n and 0 <= y + d_column < n and mas[x + d_row][y + d_column]== 0:
        x += d_row
        y += d_column
        mas[x][y] = i
        i += 1
    else:
        if d_column == 1:
            d_column = 0
            d_row = 1
        elif d_row == 1:
            d_row = 0
            d_column = -1
        elif d_column == -1:
            d_column = 0
            d_row = -1
        elif d_row == -1:
            d_row = 0
            d_column = 1

for row in mas:
    for elem in row:
        print(str(elem).rjust(length), end=' ')
    print()


#
n = int(input())
lst = [[0] * n for i in range(n)]
i, j, di, dj = 0, 0, 0, 1
for k in range(n * n):
    lst[i][j] = k + 1
    if lst[(i + di) % n][(j + dj) % n]:
        di, dj = dj, -di
    i, j = i + di, j + dj
for line in lst:
    print(*line)


#
n = int(input())
l = [[0] * n for i in range(n)]
c = 1
for i in range(n):
    for j in range(i, n - i):
        l[i][j] = c
        c += 1
    for j in range(i + 1, n - i):
        l[j][n - i - 1] = c
        c += 1
    for j in range(n - i - 2, -1 + i, -1):
        l[n - i - 1][j] = c
        c += 1
    for j in range(n - 2 - i, i, -1):
        l[j][i] = c
        c += 1

for i in l:
    print(*i)


#
n = int(input())
a = [[n * n] * n for _ in range(n)]
m = n - 1
k = 0
l_up = 1  # Значение в левом верхнем углу квадрата
while m > 0:
    for i in range(m):
        a[k][k + i] = l_up + i  # Верхняя сторона квадрата
        a[m + k][k + i + 1] = 3 * m + l_up - i - 1  # Нижняя сторона квадрата
        a[k + i][m + k] = m + l_up + i  # Правая сторона квадрата
        a[m + k - i][k] = 3 * m + l_up + i  # Левая сторона квадрата
    l_up += 4 * m
    m -= 2
    k += 1
for i in a:
    print(*i)


#
n = int(input()) # ввод размера матрицы
lst = [[0] * n for i in range(n)] # создание нулевой матрицы
i = 0  # i - строка (равен нулю потому, что цикл начинает свой обход с верхней строки)
j = 0  # j - столбец (равен нулю потому, что цикл начинает свой обход с левого столбца)
di = 0  # di - смещениe строки (равен нулю потому, что  обход начинается слева направо в  одной строке)
dj = 1  # dj - смещениe столбца (равен единице потому, что обход начинается  в пределах одной строки слева направо)

for k in range(n**2):  # цикл обходит все ЗНАЧЕНИЯ матрицы-вывода
    lst[i][j] = k + 1  # присваение значения в выбранную ячейку
    if lst[(i + di) % n][(j + dj) % n]:
        """
        Если следующая ячейка равна положительному числу, то выполняется код ниже.
        Деление индекса по остатку на длину матрицы нужно во избежание IndexError,
        когда текущая ячейка явлется последней в своей последовательности(т.е. следующей не существует).
        Тогда этой ячейкой будет являться ранее заполненая(первой ячейкой текущей ряда или столбца).
        """
        di, dj = dj, -di
        """
        происходит изменение вектора движение "курсора" по ЧАСОВОЙ стрелке,
        в этом можно убедиться на примере:
        di = 0 => di = 1 => di = 0  => di = -1 => di = 0    пара вернулась
        dj = 1 => dj = 0 => dj = -1 => dj = 0  => dj = 1    к начальнем значениям
        вправо => вниз   => влево   => вверх   => вправо    это вектор движения
        """
    i = i + di  # строка следующей ячейки
    j = j + dj  # столбец следующей ячейки

for line in lst: # просто вывод готовой матрицы
    print(*line)


#
n = int(input())
a = [[0] * n for _ in range(n)]
dr, dc, r, c = 0, 1, 0, 0

for cnt in range(1, n ** 2 + 1):
    a[r][c] = cnt
    if a[(r + dr) % n][(c + dc) % n]:
        dr, dc = dc, -dr
    r += dr
    c += dc

for row in a:
    print(*(e for e in row))




# A. МАТЧИ
# Манао работает на спортивном телевидении. Он долгое время наблюдал за футбольными матчами чемпионата одной страны и
# начал замечать разные закономерности. Например, у каждой команды есть две формы: домашняя и выездная. Когда команда
# проводит матч на своем стадионе, футболисты надевают домашнюю форму, а когда на чужом — выездную. Единственное
# исключение из этого правила — когда цвет домашней формы принимающей команды совпадает с цветом формы гостей. В таком
# случае домашняя команда облачается в свою выездную форму. Цвета домашней и выездной формы для каждой команды различны.
# В чемпионате страны участвует n команд и он состоит из n·(n-1) матчей: каждая из команд принимает каждую другую команду
# на своем стадионе. Манао задумался, а сколько раз в течение одного чемпионата случится, что команда, играющая на своем
# стадионе, оденет выездную форму? Обратите внимание, что для подсчета этого количества порядок матчей не играет никакого з
# начения.
# Вам даны цвета домашней и выездной формы каждой команды. Для удобства эти цвета пронумерованы целыми числами таким
# образом, что никакие два разных цвета не имеют одинаковый номер. Помогите Манао найти ответ на его вопрос.
# Входные данные:
# В первой строке содержится целое число n (2≤n≤30). В каждой из следующих n строк записана пара разделенных одним
# пробелом различных целых чисел hi, ai (1≤hi,ai≤100) — номер цвета домашней и выездной форм i-ой команды соответственно.
# Выходные данные:
# В единственной строке выведите количество матчей, в которых домашняя команда выступит в выездной форме.






# ЗАПОЛНЕНИЕ ЗМЕЙКОЙ
# Даны числа n и m. Создайте массив A[n][m] и заполните его змейкой (см. пример).
# Входные данные:
# Программа получает на вход два числа n и m.
# Выходные данные:
# Программа должна вывести  полученный массив, при этом между числами может быть любое количество пробелов.
# Sample Input:
# 4 10
# Sample Output:
# 0  1  2  3  4  5  6  7  8  9
# 19 18 17 16 15 14 13 12 11 10
# 20 21 22 23 24 25 26 27 28 29
# 39 38 37 36 35 34 33 32 31 30