# Функция генератор. Создание генератора при помощи yield.
'''
Давайте вспомним как работает обычная функция
def generator():
         return [1,3,4,5]
при вызове функции generator() – нам разом вернется список [1,3,4,5], но функция генератор представляет из себя функцию которая запоминаем на каком обьекте происходила итерация и возвращает элементы по одному.
Чтобы написать такую функцию смотрите ниже:
def generator():
         for i in range(1,6):
                   yield i – yield это ключевое слово для генератора

давайте сохраним функцию в переменную а:
a = generator()
Теперь мы можем обращаться к нашей переменной а (которая хранит функцию генератор) через функцию next

print(next(a)) – такой вызов будет возвращать по одному элементу из указанных в функции range(1,6)

Так как эта функция – генератор. Элементы ее можно обойти только один раз!
Еще раз о ключевом слове yield – Она в буквально смысле замораживает функцию на том месте где она вызывалась и если у вас после нее есть код то он выполнится только при следующем вызове функции:

def sayGenerator():
         a = 'like'
         for i in range(5):
                   yield i
                   print(a)

a = sayGenerator() – сохраняем функцию в переменную а
print(next(a)) – при первом вызове мы выполним итерацию цикла for и выведется цифра 0
print(next(a)) – это второй вызов и так как в первом вызове мы вывели число с цикла for а после него шло ключевое слово yield – оно заморозило фунцию и при втором вызове фунцию продолжит выполнять код уже после выполнения первой итерации цикла – тоесть выведется like

Где такая функция генератор может понадобится?
Например мы делаем функцию factorial которая находит факториал числа от 2 до n – n укажет пользователь.
Факториалы мы будем записывать в список и вернем их сразу.

def factorial(x): – факториал с аргументом х – от 0 до x+1
         pr = 1 – переменная в которой будут считаться факториалы.
            a = [] – список в котором будут храниться факториалы
            for i in range(2, i+1): почему с двух? Умножать 1 на 1 нет смысла.
                        pr = pr * i – записываем в пр факториал.
                   a.append(pr) – записываем факториал в список
         return a – возвращаем все факториалы числа x

Теперь фунция вернет список в котором хранятся факториалы числа x. Но этот список будет занимать место в памяти. И это можно решить функцией генератором
def factorialGenerator(x): – функция генератор факториал.
         Pr = 1 – переменная в которую записывается факториал
         for i in range(2, x+1): обходим все цифры от 2 до х + 1
                   pr = pr * i – записываем факториал в pr
                   yield pr – возвращаем факториал i числа.

Теперь наша функция будет возвращать факториал от 2 до x и она итерабельна, тоесть можно к ней вызывать функцию next.
И самое главное она не занимает места в памяти.
'''
