# Функция генератор. Создание генератора при помощи yield.
'''
Давайте вспомним как работает обычная функция
def generator():
         return [1,3,4,5]
при вызове функции generator() – нам разом вернется список [1,3,4,5], но функция генератор представляет из себя функцию которая запоминаем на каком обьекте происходила итерация и возвращает элементы по одному.
Чтобы написать такую функцию смотрите ниже:
def generator():
         for i in range(1,6):
                   yield i – yield это ключевое слово для генератора

давайте сохраним функцию в переменную а:
a = generator()
Теперь мы можем обращаться к нашей переменной а (которая хранит функцию генератор) через функцию next

print(next(a)) – такой вызов будет возвращать по одному элементу из указанных в функции range(1,6)

Так как эта функция – генератор. Элементы ее можно обойти только один раз!
Еще раз о ключевом слове yield – Она в буквально смысле замораживает функцию на том месте где она вызывалась и если у вас после нее есть код то он выполнится только при следующем вызове функции:

def sayGenerator():
         a = 'like'
         for i in range(5):
                   yield i
                   print(a)

a = sayGenerator() – сохраняем функцию в переменную а
print(next(a)) – при первом вызове мы выполним итерацию цикла for и выведется цифра 0
print(next(a)) – это второй вызов и так как в первом вызове мы вывели число с цикла for а после него шло ключевое слово yield – оно заморозило фунцию и при втором вызове фунцию продолжит выполнять код уже после выполнения первой итерации цикла – тоесть выведется like

Где такая функция генератор может понадобится?
Например мы делаем функцию factorial которая находит факториал числа от 2 до n – n укажет пользователь.
Факториалы мы будем записывать в список и вернем их сразу.

def factorial(x): – факториал с аргументом х – от 0 до x+1
         pr = 1 – переменная в которой будут считаться факториалы.
            a = [] – список в котором будут храниться факториалы
            for i in range(2, i+1): почему с двух? Умножать 1 на 1 нет смысла.
                        pr = pr * i – записываем в пр факториал.
                   a.append(pr) – записываем факториал в список
         return a – возвращаем все факториалы числа x

Теперь фунция вернет список в котором хранятся факториалы числа x. Но этот список будет занимать место в памяти. И это можно решить функцией генератором
def factorialGenerator(x): – функция генератор факториал.
         Pr = 1 – переменная в которую записывается факториал
         for i in range(2, x+1): обходим все цифры от 2 до х + 1
                   pr = pr * i – записываем факториал в pr
                   yield pr – возвращаем факториал i числа.

Теперь наша функция будет возвращать факториал от 2 до x и она итерабельна, тоесть можно к ней вызывать функцию next.
И самое главное она не занимает места в памяти.
'''
def f():
    return [43, 65, 32]

def genf():
    s = 7
    for i in [43, 65, 32]:
        yield i
        print(s)
        s = s*10 + 7

for i in genf():
    print(i)

# yeld возвращает значение и замораживает выполнение функции на данном этапе.
g = genf()
print(next(g))
print(next(g))

# Список факториалов чисел:
print('Список факториалов чисел:')
def fact(n):
    pr = 1
    a = []
    for i in range(1, n + 1):
        pr = pr*i
        a.append(pr)
    return a

print(fact(10)) # Результат будет списком

# Функция генератор факториала:
print('Функция генератор факториала:')
def fact(n):
    pr = 1
    for i in range(1, n + 1):
        pr = pr*i
        yield pr

for i in fact(10):
    print(i, end=' ') # Результат - не список