# Функция zip.
'''
Вот у нас есть два списка:
a = [1, 2, 3, 4, 5]
b = [100, 200, 300, 400, 500]
Нам нужно вывести в одну строчку пару с двух списков которые стоят на одинаковы индексах, тоесть индекс начинается с 0.
В списке а под нулевым индексом стоит -  1, а в списке б – 100
Нам нужно так вывести все пары каждую на отдельной строчке и это можно сделать циклов for
for i in range(len(a)): – указываем в range() длину списка а(можно и b но нет разницы у них одинаковая длина)
         print(a[i], b[i]) – range(len(a)) – выдаст 5 элементов – 0,1,2,3,4 а эти числа совпадают с индексами элементов
         двух списков и если указать переменную i В которой по очередно будут поступать числа от 0 до 4 то мы можем вывести в обоих списках по одному элементу начания с нулевого индекса
Вывод: 1 100
2 200
3 300
4 400
5 500
Мы получили то что нам нужно но этот код можно заменить одной функцией zip:
zip() принимает аргументами несколько итерабельных последовательностей(tuple, list) и выводит их элементы стоящие на одном индексе парно каждую в отдельной строке:
print(zip(a, b)) – первым аргументом мы передали список а, вторым передали список б.
Данное выражение вернет нам zip Обьект: <zip object at 0x02C0A488>
Zip обьект является итератором а как мы знаем итератор можно превратить в итерабельную последовательность например кортеж(tuple):
print(tuple(zip(a, b))) – данный код выведет нам пары в одну строчку но так как на нужно вывести их каждую в отдельной строке сделаем так:
print(*tuple(zip(a, b)), sep='\n') – тут мы передаем парамет sep=’\n’
который является параметров функции print() в параметре sep`а мы указали \n тоесть переходи на следующую строку, и так
после каждого вывода новой пары мы будем переходить на следующую строку, а ‘*’в начален принта убирает запятые.
Вывод:
(1, 100)
(2, 200)
(3, 300)
(4, 400)
(5, 500)
Как видите все работает.
Также можно добавить третий аргумент.
c = ‘abcde’ – переменная ‘c’ с строкой
Далее делаем все тоже самое:
print(*tuple(zip(a, b, c)), sep='\n') – просто добавляем переменную с как третий аргумент.
Вывод:
(1, 100, 'a')
(2, 200, 'b')
(3, 300, 'c')
(4, 400, 'd')
(5, 500, 'e')
Если вас не устраивают скобки, можете делать так:
for i in zip(a, b, c): - обходим все элементы трех переменных
         print(*i) – выводим их с приставкой ‘*’ чтобы не было скобок
Чтобы из zip обьекта снова вернуть наши былые списки или кортежи делаем так:
result = zip(a,b,c) -  записываем в оператор result zip обьект
a1, b1, c1 = zip(*rezult) – записываем в три переменные элементы оператора result в котором хранится Zip object, * там
берет элементы стоящие под первым индексом и кладет их по одному в три оператора и так делает до последнего индекса.
print(a1, b1, c1) -  в трех переменных готовые списки которые соответствуют спискам изначальным.
'''
a = [5, 6, 7, 8]
b = [100, 200, 300, 40]

for i in range(4):
    print(a[i], b[i])

# Функция zip() принимает несколько итерабельных последовательностей
# zip(iter1 [, iter2 [...]]) --> zip object

rez = zip(a, b)
print(rez) # Итератор. Можно превратить в какую-то другую коллекцию.

print(list(rez)) # Создает несколько кортежей, в каждом из которых элементы списков, с одинаковыми индексами

# Сцепления происходят по меньшему списку (кортежей будет такое количество, сколько значений в наименьшей коллекции):

a = [5, 6, 7]
b = [100, 200, 300, 40]
print(list(zip(a, b)))


a = [5, 6, 7, 8]
b = [100, 200, 300, 40]
rez = zip(a, b)
for i in rez:
    print(i)

# Ограничения на количество итерабельных последовательностей нет
c = 'abcd'
rez1 = list(zip(a, b, c))
print(rez1)

for t1, t2, t3 in zip(a, b, c):
    print(t1, t2, t3)


# Как обратно получить списки из zip:
print('Как обратно получить списки из zip:')
a = [5, 6, 7, 8]
b = [100, 200, 300, 40]
c = 'abcd'

rez = zip(a, b, c)
#print(list(rez))

col1, col2, col3 = zip(*rez)
print(col1, col2, col3)










